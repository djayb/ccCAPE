{% extends "base.html" %}
{% block content %}
<section class="issue-header">
  <div>
    <h1>Ops Health</h1>
    <div class="meta-row">Freshness, reliability, and coverage (free-data proxy).</div>
  </div>
</section>

<section class="issue-layout">
  <article class="panel">
    <h2>Latest Ingestion</h2>
    {% if not pipeline %}
      <p class="muted">No pipeline runs found.</p>
    {% else %}
      <p><strong>Status:</strong> {{ pipeline.status }}</p>
      <p><strong>Started:</strong> {{ pipeline.run_started_at }}</p>
      <p><strong>Completed:</strong> {{ pipeline.run_completed_at }}</p>
      {% if pipeline.quality %}
        <p><strong>Latest price date:</strong> {{ pipeline.quality.get("latest_price_date", "-") }} ({{ pipeline.quality.get("price_age_days", "-") }} days)</p>
        <p><strong>Latest CPI date:</strong> {{ pipeline.quality.get("latest_cpi_date", "-") }} ({{ pipeline.quality.get("cpi_age_days", "-") }} days)</p>
        <p><strong>Latest Shiller date:</strong> {{ pipeline.quality.get("shiller_latest_observation_date", "-") }} ({{ pipeline.quality.get("shiller_age_days", "-") }} days)</p>
        <p><strong>Facts CIKs:</strong> {{ pipeline.quality.get("facts_cik_count", "-") }}</p>
        <p><strong>Priced symbols:</strong> {{ pipeline.quality.get("priced_symbol_count", "-") }}</p>
        {% if pipeline.quality.get("warnings") %}
          <div class="muted" style="margin-top: 0.6rem;">Warnings:</div>
          <ul>
            {% for w in pipeline.quality.get("warnings", []) %}
              <li>{{ w }}</li>
            {% endfor %}
          </ul>
        {% endif %}
      {% endif %}
    {% endif %}
  </article>

  <article class="panel">
    <h2>Latest Calculation</h2>
    {% if not calc %}
      <p class="muted">No CC CAPE runs found.</p>
    {% else %}
      <p><strong>Run ID:</strong> {{ calc.run_id }}</p>
      <p><strong>Run At:</strong> {{ calc.run_at }}</p>
      <p><strong>As-of price date:</strong> {{ calc.latest_price_date }}</p>
      <p><strong>CC CAPE:</strong> {{ "%.4f"|format(calc.cc_cape) }}</p>
      {% if calc.shiller_cape is not none %}
        <p><strong>Shiller CAPE:</strong> {{ "%.4f"|format(calc.shiller_cape) }} {% if calc.shiller_cape_date %}<span class="muted">(as of {{ calc.shiller_cape_date }})</span>{% endif %}</p>
      {% endif %}
      {% if calc.cape_spread is not none %}
        <p><strong>Spread:</strong> {{ "%.4f"|format(calc.cape_spread) }}</p>
      {% endif %}
      <p><strong>Coverage:</strong> {{ calc.symbols_with_valid_cape }} / {{ calc.symbols_total }} valid CAPE</p>
      <p><strong>Weighting:</strong> <code>{{ calc.weighting_method }}</code> (mcap coverage {{ "%.3f"|format(calc.market_cap_coverage) }})</p>
    {% endif %}
  </article>
</section>

<section class="panel" style="margin-top: 1rem;">
  <h2>Monthly Series</h2>
  {% if not series %}
    <p class="muted">No monthly series found yet.</p>
    <p class="muted">Run: <code>python3 scripts/backfill_cc_cape_series_free.py --series-years 10 --update-tracker</code></p>
  {% else %}
    <p><strong>As-of constituents:</strong> {{ series.as_of_constituents_date }}</p>
    <p><strong>Range:</strong> {{ series.min_observation_date }} to {{ series.max_observation_date }}</p>
    <p><strong>Observations:</strong> {{ series.count }}</p>
    <p><strong>Latest CC CAPE:</strong> {{ "%.4f"|format(series.latest_cc_cape) }}</p>
    <p class="muted">Export: <a href="/metrics/cc-cape/export/series_monthly.csv?as_of_constituents_date={{ series.as_of_constituents_date }}">series_monthly.csv</a></p>
  {% endif %}
</section>

<section class="panel" style="margin-top: 1rem;">
  <h2>Coverage Over Time</h2>
  <div class="muted">From monthly series (<code>cc_cape_series_monthly</code>).</div>
  <div class="muted" style="margin-top: 0.35rem;">
    <span style="color:#0b6bcb; font-weight:700;">Priced %</span>
    and
    <span style="color:#067647; font-weight:700;">Valid CAPE %</span>
    of total constituents.
  </div>
  <div style="margin-top: 0.75rem;">
    <canvas id="coverageChart" class="chart-canvas" height="240"></canvas>
  </div>
  <div id="coverageError" class="muted" style="margin-top: 0.5rem;"></div>
</section>

<section class="panel" style="margin-top: 1rem;">
  <h2>Reports</h2>
  {% if qa_report %}
    <p>
      <strong>QA report:</strong>
      <a href="/docs/view/{{ qa_report.relpath }}"><code>docs/{{ qa_report.relpath }}</code></a>
      <span class="muted">(updated {{ qa_report.mtime }})</span>
    </p>
  {% else %}
    <p class="muted">QA report not found yet.</p>
    <p class="muted">Run: <code>python3 scripts/generate_qa_report.py --out docs/QA_REPORT.md --update-tracker</code></p>
  {% endif %}

  {% if kpi_report %}
    <p>
      <strong>KPI baseline:</strong>
      <a href="/docs/view/{{ kpi_report.relpath }}"><code>docs/{{ kpi_report.relpath }}</code></a>
      <span class="muted">(updated {{ kpi_report.mtime }})</span>
    </p>
  {% else %}
    <p class="muted">KPI baseline report not found yet.</p>
    <p class="muted">Run: <code>python3 scripts/generate_kpi_report.py --out docs/KPI_BASELINE.md --update-tracker</code></p>
  {% endif %}
</section>

<script>
(function () {
  function toNumber(x) {
    if (x === null || x === undefined) return null;
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }

  function resizeCanvasToCssPixels(canvas) {
    const dpr = window.devicePixelRatio || 1;
    const cssW = Math.max(1, canvas.clientWidth);
    const cssH = Math.max(1, canvas.getAttribute("height") ? Number(canvas.getAttribute("height")) : canvas.clientHeight);
    const needW = Math.floor(cssW * dpr);
    const needH = Math.floor(cssH * dpr);
    if (canvas.width !== needW || canvas.height !== needH) {
      canvas.width = needW;
      canvas.height = needH;
    }
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { ctx, cssW, cssH };
  }

  function drawLineChart(canvas, labels, seriesList, opts) {
    const { ctx, cssW, cssH } = resizeCanvasToCssPixels(canvas);
    ctx.clearRect(0, 0, cssW, cssH);

    const pad = { l: 46, r: 14, t: 14, b: 28 };
    const plotW = cssW - pad.l - pad.r;
    const plotH = cssH - pad.t - pad.b;
    if (plotW <= 10 || plotH <= 10 || labels.length < 2) return;

    const values = [];
    for (const s of seriesList) {
      for (const v of s.data) {
        if (v !== null) values.push(v);
      }
    }
    if (values.length === 0) return;

    let minV = Math.min(...values);
    let maxV = Math.max(...values);
    if (minV === maxV) {
      minV -= 1;
      maxV += 1;
    }
    const range = maxV - minV;
    const yMin = minV - range * 0.05;
    const yMax = maxV + range * 0.05;

    function xFor(i) {
      return pad.l + (i / (labels.length - 1)) * plotW;
    }
    function yFor(v) {
      const t = (v - yMin) / (yMax - yMin);
      return pad.t + (1 - t) * plotH;
    }

    // Grid
    ctx.strokeStyle = "#e6edf8";
    ctx.lineWidth = 1;
    for (let g = 0; g <= 4; g++) {
      const y = pad.t + (g / 4) * plotH;
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + plotW, y);
      ctx.stroke();
    }

    // Axes labels (min/max)
    ctx.fillStyle = "#5c6a82";
    ctx.font = "12px IBM Plex Sans, Segoe UI, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(yMax.toFixed(opts && opts.yDecimals !== undefined ? opts.yDecimals : 2), 8, pad.t);
    ctx.textBaseline = "bottom";
    ctx.fillText(yMin.toFixed(opts && opts.yDecimals !== undefined ? opts.yDecimals : 2), 8, pad.t + plotH);

    // Lines
    for (const s of seriesList) {
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      let started = false;
      for (let i = 0; i < labels.length; i++) {
        const v = s.data[i];
        if (v === null) {
          started = false;
          continue;
        }
        const x = xFor(i);
        const y = yFor(v);
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    }

    // X labels (first/last)
    ctx.fillStyle = "#5c6a82";
    ctx.font = "12px IBM Plex Sans, Segoe UI, sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    ctx.fillText(labels[0], pad.l, pad.t + plotH + 8);
    ctx.textAlign = "right";
    ctx.fillText(labels[labels.length - 1], pad.l + plotW, pad.t + plotH + 8);
  }

  async function renderCoverage() {
    const errorEl = document.getElementById("coverageError");
    const canvas = document.getElementById("coverageChart");
    if (!canvas) return;

    try {
      const resp = await fetch("/api/metrics/cc-cape/series/monthly?limit=720", {
        headers: { Accept: "application/json" },
      });
      if (!resp.ok) {
        throw new Error("Failed to load monthly series (" + resp.status + ")");
      }
      const payload = await resp.json();
      const series = (payload && payload.series) ? payload.series : [];
      if (series.length < 2) {
        errorEl.textContent = "Not enough monthly observations to chart yet.";
        return;
      }
      const labels = series.map((p) => String(p.observation_date || "").slice(0, 10));
      const pricedPct = series.map((p) => {
        const priced = toNumber(p.symbols_with_price);
        const total = toNumber(p.symbols_total);
        if (!priced || !total) return null;
        return (priced / total) * 100.0;
      });
      const validPct = series.map((p) => {
        const valid = toNumber(p.symbols_with_valid_cape);
        const total = toNumber(p.symbols_total);
        if (!valid || !total) return null;
        return (valid / total) * 100.0;
      });

      drawLineChart(canvas, labels, [
        { name: "Priced %", data: pricedPct, color: "#0b6bcb" },
        { name: "Valid %", data: validPct, color: "#067647" },
      ], { yDecimals: 1 });
      errorEl.textContent = "";
    } catch (err) {
      errorEl.textContent = "Coverage chart error: " + (err && err.message ? err.message : String(err));
    }
  }

  renderCoverage().catch(function () {});
  window.addEventListener("resize", function () {
    clearTimeout(window.__cccapeCoverageResizeTimer);
    window.__cccapeCoverageResizeTimer = setTimeout(renderCoverage, 150);
  });
})();
</script>

{% endblock %}
